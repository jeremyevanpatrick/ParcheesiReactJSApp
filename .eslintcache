[{"C:\\Users\\Jeremy\\Desktop\\Projects\\root\\portfolio\\apps\\parcheesi\\src\\index.js":"1"},{"size":53398,"mtime":1611725028000,"results":"2","hashOfConfig":"3"},{"filePath":"4","messages":"5","errorCount":0,"warningCount":144,"fixableErrorCount":0,"fixableWarningCount":0,"source":"6"},"1qagyau","C:\\Users\\Jeremy\\Desktop\\Projects\\root\\portfolio\\apps\\parcheesi\\src\\index.js",["7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150"],"import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\nclass Dice extends React.Component {\r\n  \tconstructor(props){\r\n    \tsuper(props);\r\n  \t}\r\n\r\n  \trender(){\r\n  \t\tconst diceHtml = [];\r\n\r\n\t  \tif(this.props.dice.length > 0){\r\n\t  \t\tfor(var a=0;a<this.props.dice.length;a++){\r\n\t  \t\t\t\r\n\t  \t\t\tvar diceClass = \"die die-\" + this.props.dice[a].number;\r\n\t  \t\t\tif(!this.props.dice[a].active){\r\n\t  \t\t\t\tdiceClass += \" spentDie\";\r\n\t  \t\t\t}\r\n\r\n\t  \t\t\tdiceHtml.push(\r\n\t  \t\t\t\t<div className={diceClass}>\r\n\t  \t\t\t\t\t<span>•</span>\r\n\t  \t\t\t\t\t<span>•</span>\r\n\t  \t\t\t\t\t<span>•</span>\r\n\t  \t\t\t\t\t<span>•</span>\r\n\t  \t\t\t\t\t<span>•</span>\r\n\t  \t\t\t\t\t<span>•</span>\r\n\t  \t\t\t\t\t<b>10</b>\r\n\t  \t\t\t\t\t<strong>20</strong>\r\n\t  \t\t\t\t</div>\r\n  \t\t\t\t);\r\n\t  \t\t}\r\n\t  \t}\r\n\r\n\t  \treturn diceHtml;\r\n  \t}\r\n}\r\n\r\nclass Token extends React.Component {\r\n  \tconstructor(props){\r\n    \tsuper(props);\r\n  \t}\r\n\r\n\thandleDragStart(e){\r\n\t\treturn false;\r\n\t}\r\n\r\n  \trender(){\r\n\t\tvar playerClass = \"token player\" + this.props.player + \"Token\";\r\n\r\n\t\tlet mouseDownCallback = function(){};\r\n\t\tlet mouseUpCallback = function(){};\r\n\t\tif(this.props.dice.length>0 && this.props.player == this.props.turn && this.props.human == true){\r\n\t\t\tmouseDownCallback = this.props.onMouseDownMarker;\r\n\t\t\tmouseUpCallback = this.props.onMouseUpMarker;\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tclassName={playerClass}\r\n\t            draggable={false}\r\n\t            onDragStart={(e) => this.handleDragStart(e)}\r\n\t            onMouseDown={mouseDownCallback}\r\n  \t\t\t\tonMouseUp={mouseUpCallback}\r\n  \t\t\t\ttokenindex={this.props.tokenindex}\r\n\t\t\t></div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass Space extends React.Component {\r\n  \tconstructor(props){\r\n    \tsuper(props);\r\n  \t}\r\n\r\n  \trender(){\r\n\t\tvar classString = \"space\";\r\n\t\tif(this.props.safe){\r\n\t\t\tclassString += \" safe\";\r\n\t\t}\r\n\t\tif(this.props.showMoves.length > 0 && this.props.showMoves.indexOf(this.props.spaceIndex) != -1){\r\n\t\t\tclassString += \" highlightSpace\";\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\t<div\r\n\t\t\t\tpositionindex={this.props.spaceIndex}\r\n\t\t\t\tclassName={classString}\r\n\t\t\t>\r\n\t\t\t\t{this.props.renderMarkers(this.props.spaceIndex)}\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nclass Quadrant extends React.Component {\r\n  \tconstructor(props){\r\n    \tsuper(props);\r\n  \t}\r\n\r\n  \trenderMarkers(positionIndex){\r\n    \tconst players = this.props.players.slice();\r\n  \t\tlet markersToRender = getMarkersToRender(players, positionIndex);\r\n\t\tconst tokenArray = [];\r\n\t\tfor(var g=0;g<markersToRender.length;g++){\r\n\t\t\ttokenArray.push(\r\n\t\t\t\t<Token\r\n\t\t\t\t\tturn={this.props.turn}\r\n\t\t\t\t\tdice={players[this.props.turn-1].dice}\r\n\t\t\t\t\tplayer={markersToRender[g]}\r\n\t\t\t\t\tonMouseDownMarker={this.props.onMouseDownMarker}\r\n      \t\t\t\tonMouseUpMarker={this.props.onMouseUpMarker}\r\n      \t\t\t\ttokenindex={positionIndex}\r\n      \t\t\t\thuman={players[this.props.turn-1].human}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn tokenArray;\r\n  \t}\r\n\r\n\trenderSpaceGroup(groupType, safeIndex, spaceNumbers) {\r\n\t\tconst spaceArray = [];\r\n\t\tfor (let i = 0; i < 8; i++) {\r\n\t\t\tspaceArray.push(\r\n\t\t\t\t<Space\r\n\t\t\t\t\tspaceIndex={spaceNumbers[i]}\r\n\t\t\t\t\tsafe={(i==safeIndex)}\r\n        \t\t\tshowMoves={this.props.showMoves}\r\n        \t\t\trenderMarkers={(x) => this.renderMarkers(x)}\r\n\t\t\t\t\tonMouseDownMarker={this.props.onMouseDownMarker}\r\n      \t\t\t\tonMouseUpMarker={this.props.onMouseUpMarker}\r\n    \t\t\t/>\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\t<div className={groupType}>\r\n\t\t\t\t{spaceArray}\r\n\t\t\t</div>\r\n\t\t)\r\n\t}\r\n\r\n\trender(){\r\n\t\tvar i = this.props.quadIndex;\r\n\r\n\t\tif(i % 2 == 0){\r\n\t\t\tif(i == 4){\r\n\t\t\t\t//Home\r\n\r\n\t\t\t  \tvar menuClass = \"centerMenu playerTurn\" + this.props.turn;\r\n\t\t\t  \t\r\n\t\t\t  \tconst homeSpaces = [];\r\n\t\t\t  \tif(this.props.gameState == 0 || this.props.gameState == 1){\r\n\t\t\t\t  \tfor(var h=0; h<this.props.players.length;h++){\r\n\t\t\t\t  \t\t\r\n\t\t\t\t  \t\tvar classString = \"playerHome playerHome\";\r\n\t\t\t\t  \t\tvar e = this.props.players[h].enters;\r\n\t\t\t\t  \t\tclassString += (e==38 ? \"Bottom\" : (e==55 ? \"Right\" : (e==4 ? \"Top\" : \"Left\")));//e==21\r\n\r\n\t\t\t  \t\t\tvar posIndex = ((this.props.players[h].player * (-1)) - 10);\r\n\r\n\t\t\t\t\t\tif(this.props.showMoves.length > 0 && this.props.showMoves.indexOf(posIndex) != -1){\r\n\t\t\t\t\t\t\tclassString += \" highlightSpace\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t  \t\t\thomeSpaces.push(\r\n\t\t\t  \t\t\t\t<div\r\n\t\t\t\t\t\t\t\tclassName={classString}\r\n\t\t\t\t\t\t\t\tpositionindex={posIndex}\r\n\t      \t\t\t\t\t>\r\n\t      \t\t\t\t\t\t{this.renderMarkers(posIndex)}\r\n\t  \t\t\t\t\t\t</div>\r\n\t\t\t  \t\t\t);\r\n\t\t\t\t  \t}\r\n\t\t\t  \t}\r\n\r\n\t\t\t  \tlet mainLabelText = \"\";\r\n\t\t\t  \tvar centerBtnHtml = null;\r\n\t\t\t  \tlet lowerAreaHtml = null;\r\n\r\n\t\t\t  \tif(this.props.gameState == -1){\r\n\r\n\t\t\t  \t\t//pre menu\r\n\t\t\t  \t\tmenuClass += \" preMenu\";\r\n\r\n\t\t\t  \t\tmainLabelText = \"Parcheesi\";\r\n\r\n\t\t\t  \t\tlet rollBtnClass = \"disableBtn\";\r\n\t\t\t  \t\tlet activePlayerCount = 0;\r\n\t\t\t  \t\tfor(var x=0; x < this.props.players.length; x++){\r\n\t\t\t  \t\t\tif(this.props.players[x].human != null){\r\n\t\t\t  \t\t\t\tactivePlayerCount++;\r\n\t\t\t  \t\t\t}\r\n\t\t\t  \t\t}\r\n\t\t\t  \t\t//only start game if there are at least 2 players\r\n\t\t\t  \t\tif(activePlayerCount > 1){\r\n\t\t\t  \t\t\trollBtnClass = \"\";\r\n\t\t\t  \t\t}\r\n\r\n\t\t\t  \t\tcenterBtnHtml = (\r\n\t\t\t  \t\t\t<div\r\n\t\t\t\t\t\t\tid=\"rollBtn\"\r\n\t\t\t\t\t\t\tclassName={rollBtnClass}\r\n\t\t\t\t\t\t\tonClick={this.props.onClickStartGame}\r\n\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\tStart Game\r\n\t\t\t\t\t\t</div>\r\n\t\t\t  \t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\tconst playerTrHtml = [];\r\n\t\t\t  \t\tfor(let a=1; a<=4;a++){\r\n\t\t\t  \t\t\t\r\n\t\t\t  \t\t\tlet pId = \"p_\" + a;\r\n\t\t\t  \t\t\tlet cpu = \"cpu_\" + a;\r\n\t\t\t  \t\t\tlet off = \"off_\" + a;\r\n\t\t\t  \t\t\tlet pc = \"pc_\" + a;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tlet checked1 = \"\";\r\n\t\t\t  \t\t\tlet checked2 = \"\";\r\n\t\t\t  \t\t\tlet checked3 = \"\";\r\n\r\n\t\t\t  \t\t\tif(this.props.players[a-1].human == null){\r\n\t\t\t  \t\t\t\tchecked1 = \"checked\";\r\n\t\t\t  \t\t\t}else if(!this.props.players[a-1].human){\r\n\t\t\t  \t\t\t\tchecked2 = \"checked\";\r\n\t\t\t  \t\t\t}else if(this.props.players[a-1].human){\r\n\t\t\t  \t\t\t\tchecked3 = \"checked\";\r\n\t\t\t  \t\t\t}\r\n\r\n\t\t\t  \t\t\tplayerTrHtml.push(\r\n\t\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t\t<td>Player {a}</td>\r\n\t\t\t\t\t\t\t\t<td>\r\n\t\t\t\t\t\t\t\t\t<div className=\"switch-toggle switch-3 switch-candy\">\r\n\t\t\t\t\t\t\t\t\t\t<input id={pId} name={pc} type=\"radio\" defaultChecked={checked3} onChange={this.props.onChangeConfigurePlayer} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={pId}>\r\n\t\t\t\t\t\t\t\t\t\t\tP{a}\r\n\t\t\t\t\t\t\t\t\t\t</label>\r\n\t\t\t\t\t\t\t\t\t\t<input id={cpu} name={pc} type=\"radio\" defaultChecked={checked2} onChange={this.props.onChangeConfigurePlayer} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={cpu}>\r\n\t\t\t\t\t\t\t\t\t\t\tCPU\r\n\t\t\t\t\t\t\t\t\t\t</label>\r\n\t\t\t\t\t\t\t\t\t\t<input id={off} name={pc} type=\"radio\" defaultChecked={checked1} onChange={this.props.onChangeConfigurePlayer} />\r\n\t\t\t\t\t\t\t\t\t\t<label htmlFor={off}>\r\n\t\t\t\t\t\t\t\t\t\t\tOFF\r\n\t\t\t\t\t\t\t\t\t\t</label>\r\n\t\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t</tr>\r\n\t\t  \t\t\t\t);\r\n\t\t\t  \t\t}\r\n\r\n\t\t\t\t\tlowerAreaHtml = (\r\n\t\t\t\t\t\t<table>\r\n\t\t\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t\t\t{playerTrHtml}\r\n\t\t\t\t\t\t\t</tbody>\r\n\t\t\t\t\t\t</table>\r\n\t\t\t\t\t);\r\n\r\n\t\t\t  \t}else if(this.props.gameState == 0){\r\n\r\n\t\t\t  \t\t//game is started\r\n\t\t\t  \t\tmainLabelText = \"Player \" + this.props.turn;\r\n\r\n\t\t\t\t\tlet dice = this.props.players[this.props.turn-1].dice;\r\n\t\t\t\t  \tlet rollBtnClass = (this.props.players[this.props.turn-1].human != true || (dice.length > 0 && (dice[0].active || dice[1].active))) ? \"disableBtn\" : \"\";\r\n\r\n\t\t\t\t  \tif(this.props.turnComplete){\r\n\t\t\t\t  \t\tcenterBtnHtml = (\r\n\t\t\t\t  \t\t\t<div\r\n\t\t\t\t\t\t\t\tid=\"rollBtn\"\r\n\t\t\t\t\t\t\t\tclassName={rollBtnClass}\r\n\t\t\t\t\t\t\t\tonClick={this.props.onClickEndTurn}\r\n\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\tEnd Turn\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t  \t\t);\r\n\t\t\t\t  \t}else{\r\n\t\t\t\t  \t\tcenterBtnHtml = (\r\n\t\t\t\t  \t\t\t<div\r\n\t\t\t\t\t\t\t\tid=\"rollBtn\"\r\n\t\t\t\t\t\t\t\tclassName={rollBtnClass}\r\n\t\t\t\t\t\t\t\tonClick={this.props.onClickRollDice}\r\n\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\tRoll Dice\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t  \t\t);\r\n\t\t\t\t  \t}\r\n\r\n\t\t\t\t  \tlowerAreaHtml = (\r\n\t\t\t\t\t\t<Dice dice={dice} />\r\n\t\t\t  \t\t);\r\n\r\n\t\t\t  \t}else if(this.props.gameState == 1){\r\n\t\t\t  \t\t\r\n\t\t\t  \t\t//game is completed\r\n\t\t\t  \t\tmainLabelText = <div>Game<br/>Completed</div>;\r\n\t\t\t  \t\t\r\n\t\t\t  \t}\r\n\r\n\t\t\t\treturn (\r\n\t\t\t\t\t<div className=\"quadrant home\">\r\n    \t\t\t\t\t{homeSpaces}\r\n    \t\t\t\t\t<div className=\"innerHome\">\r\n\t    \t\t\t\t\t<div className={menuClass}>\r\n\t    \t\t\t\t\t\t<div className=\"playerTurn\">\r\n\t    \t\t\t\t\t\t\t{mainLabelText}\r\n\t    \t\t\t\t\t\t</div>\r\n\t    \t\t\t\t\t\t<div className=\"btnArea\">\r\n\t\t\t\t\t\t\t\t\t{centerBtnHtml}\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t\t<div className=\"diceArea\">\r\n\t\t\t\t\t\t\t\t\t{lowerAreaHtml}\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</div>\r\n    \t\t\t\t</div>\r\n\t\t\t\t);\r\n\t\t\t}else{\r\n\t\t\t\t\r\n\t\t\t\t//Start\r\n\t\t\t\tlet playerStartClass = \"outerCircle player\" + this.props.player + \"Start\";\r\n\t\t\t\tlet playerStartLabel = (this.props.players[this.props.player-1].human != null && (this.props.gameState == 0 || this.props.gameState == 1)) ? \"Player \" + this.props.player : \"\";\r\n\t\t\t\tlet positionIndex = this.props.player * (-1);\r\n\r\n\t\t\t\tlet markersHtml = null;\r\n\t\t\t\tif(this.props.gameState == 0 || this.props.gameState == 1){\r\n\t\t\t\t\tmarkersHtml = this.renderMarkers(positionIndex);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn (\r\n\t\t\t\t\t<div className=\"quadrant start\">\r\n\t\t\t\t\t\t<span className={playerStartClass}>\r\n\t\t\t\t\t\t\t<span className=\"innerCircle\">\r\n\t\t\t\t\t\t\t\t<div className=\"startName\">{playerStartLabel}</div>\r\n\t\t\t\t\t\t\t\t<div\r\n\t\t\t\t\t\t\t\t\tclassName=\"startPosition\"\r\n        \t\t\t\t\t\t\tpositionindex={positionIndex}\r\n\t\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\t\t{markersHtml}\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t</span>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//Spaces\r\n\t\t  \tvar groupType = (i==1||i==7) ? \"file-v\" : \"row-h\";\r\n\t\t  \tvar a = (i==1||i==3);//4-0-4\r\n\r\n\t\t  \tvar spaceNumbers1 = new Array(8);\r\n\t\t  \tvar spaceNumbers2 = new Array(8);\r\n\t\t  \tvar spaceNumbers3 = new Array(8);\r\n\t\t  \tif(i==1){\r\n\t\t  \t\t//top\r\n\t\t  \t\tspaceNumbers1 = [0,1,2,3,4,5,6,7];\r\n\t\t  \t\tspaceNumbers2 = [67,167,267,367,467,567,667,767];\r\n\t\t  \t\tspaceNumbers3 = [66,65,64,63,62,61,60,59];\r\n\t\t  \t}else if(i==3){\r\n\t\t  \t\t//left\r\n\t\t  \t\tspaceNumbers1 = [15,14,13,12,11,10,9,8];\r\n\t\t  \t\tspaceNumbers2 = [16,116,216,316,416,516,616,716];\r\n\t\t  \t\tspaceNumbers3 = [17,18,19,20,21,22,23,24];\r\n\t\t  \t}else if(i==5){\r\n\t\t  \t\t//right\r\n\t\t  \t\tspaceNumbers1 = [58,57,56,55,54,53,52,51];\r\n\t\t  \t\tspaceNumbers2 = [750,650,550,450,350,250,150,50];\r\n\t\t  \t\tspaceNumbers3 = [42,43,44,45,46,47,48,49];\r\n\t\t  \t}else if(i==7){\r\n\t\t  \t\t//bottom\r\n\t\t  \t\tspaceNumbers1 = [25,26,27,28,29,30,31,32];\r\n\t\t  \t\tspaceNumbers2 = [733,633,533,433,333,233,133,33];\r\n\t\t  \t\tspaceNumbers3 = [41,40,39,38,37,36,35,34];\r\n\t\t  \t}\r\n\r\n\t\t  \treturn (\r\n\t\t  \t\t<div className=\"quadrant\">\r\n\t\t        \t{this.renderSpaceGroup(groupType,a?4:3,spaceNumbers1)}\r\n\t\t        \t{this.renderSpaceGroup(groupType+\" ramp\",a?0:7,spaceNumbers2)}\r\n\t\t        \t{this.renderSpaceGroup(groupType,a?4:3,spaceNumbers3)}\r\n\t\t        </div>\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Board extends React.Component {\r\n  constructor(props){\r\n    super(props);\r\n  }\r\n\r\n  render() {\r\n  \tconst quadArray = [];\r\n\tfor (let i = 0; i < 3; i++) {\r\n  \t\tconst boardRow = [];\r\n\t\tfor (let j = 0 + (3*i); j < 3 + (3*i); j++) {\r\n\t\t\tboardRow.push(\r\n\t\t\t\t<Quadrant\r\n\t\t\t\t\tgameState={this.props.gameState}\r\n\t\t\t\t\tturn={this.props.turn}\r\n\t\t\t\t\tquadIndex={j}\r\n\t\t\t\t\tplayer={j==0?3:(j==2)?2:(j==6)?4:1}\r\n\t\t\t\t\tonClickRollDice={this.props.onClickRollDice}\r\n\t\t\t\t\tonMouseDownMarker={this.props.onMouseDownMarker}\r\n\t          \t\tonMouseUpMarker={this.props.onMouseUpMarker}\r\n\t          \t\tonChangeConfigurePlayer={this.props.onChangeConfigurePlayer}\r\n\t          \t\tonClickStartGame={this.props.onClickStartGame}\r\n\t\t\t\t\tonClickEndTurn={this.props.onClickEndTurn}\r\n\t\t\t\t\tturnComplete={this.props.turnComplete}\r\n\t\t\t\t\tshowMoves={this.props.showMoves}\r\n\t\t\t\t\tplayers={this.props.players}\r\n\t\t\t\t/>\r\n\t\t\t);\r\n\t\t}\r\n\t\tquadArray.push(<div className=\"boardRow\">{boardRow}</div>);\r\n\t}\r\n\r\n    return (\r\n\t  <div id=\"board\">\r\n\t  \t{quadArray}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n    \tgameState: -1,//-1=premenu; 0=started; 1=completed;\r\n    \tturn: 1,\r\n    \tturnComplete: false,\r\n    \tdoubles: 0,\r\n    \tshowMoves: [],\r\n    \tplayers: [\r\n    \t\t{\r\n    \t\t\thuman: true,\r\n    \t\t\tplayer: 1,\r\n    \t\t\tenters: 38,\r\n    \t\t\tmarkers: [-1,-1,-1,-1],\r\n    \t\t\tdice: [],\r\n    \t\t\tfinished: false,\r\n    \t\t\tblockades: []\r\n    \t\t},\r\n    \t\t{\r\n    \t\t\thuman: false,\r\n    \t\t\tplayer: 2,\r\n    \t\t\tenters: 55,\r\n    \t\t\tmarkers: [-2,-2,-2,-2],\r\n    \t\t\tdice: [],\r\n    \t\t\tfinished: false,\r\n    \t\t\tblockades: []\r\n    \t\t},\r\n    \t\t{\r\n    \t\t\thuman: false,\r\n    \t\t\tplayer: 3,\r\n    \t\t\tenters: 4,\r\n    \t\t\tmarkers: [-3,-3,-3,-3],\r\n    \t\t\tdice: [],\r\n    \t\t\tfinished: false,\r\n    \t\t\tblockades: []\r\n    \t\t},\r\n    \t\t{\r\n    \t\t\thuman: false,\r\n    \t\t\tplayer: 4,\r\n    \t\t\tenters: 21,\r\n    \t\t\tmarkers: [-4,-4,-4,-4],\r\n    \t\t\tdice: [],\r\n    \t\t\tfinished: false,\r\n    \t\t\tblockades: []\r\n    \t\t}\r\n    \t]\r\n    };\r\n\r\n    this.moveMarker = function(start, end){\r\n\t\t//update data model\r\n\t  \tconst players = this.state.players.slice();\r\n\t  \tfor(var p=0; p<players.length; p++){\r\n\t  \t\tfor(var r=0; r<players[p].markers.length; r++){\r\n\t  \t\t\tif(players[p].markers[r] == start){\r\n\t  \t\t\t\tplayers[p].markers[r] = end;\r\n\t  \t\t\t\tbreak;\r\n\t  \t\t\t}\r\n\t  \t\t}\r\n\t  \t}\r\n\r\n\t\tthis.setState({\r\n\t\t\tplayers: players\r\n\t\t});\r\n\r\n    };\r\n\r\n    this.addBonusMove = function(distance){\r\n\t  \tconst players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n    \tplayers[turn-1].dice.push({\r\n\t\t\tnumber: distance,\r\n\t\t\tactive: true\r\n\t\t});\r\n\r\n\t\tthis.setState({\r\n\t\t\tplayers: players\r\n\t\t});\r\n\r\n    };\r\n\r\n    this.rollDice = function(callback){\r\n\r\n\t  \tconst players = this.state.players.slice();\r\n\t  \tconst turn = Object.assign(this.state.turn);\r\n\t  \tlet player = players[turn-1];\r\n\r\n\t  \tlet anyActiveDice = false;\r\n\t  \tfor(var a=0; a<player.dice.length; a++){\r\n\t  \t\tif(player.dice[a].active){\r\n\t  \t\t\tanyActiveDice = true;\r\n\t  \t\t}\r\n\t  \t}\r\n\r\n\t  \tif(player.dice.length == 0 || (!anyActiveDice && this.state.doubles > 0)){\r\n\t  \t\tplayer.dice = [\r\n\t  \t\t\t{\r\n\t  \t\t\t\tnumber: Math.floor(Math.random() * 6) + 1,\r\n\t  \t\t\t\tactive: true\r\n\t  \t\t\t},\r\n\t  \t\t\t{\r\n\t  \t\t\t\tnumber: Math.floor(Math.random() * 6) + 1,\r\n\t  \t\t\t\tactive: true\r\n\t  \t\t\t}\r\n\t  \t\t];\r\n\r\n\t  \t\t//render dice roll before proceeding\r\n\t  \t\tthis.setState({\r\n\t  \t\t\tplayers: players\r\n\t  \t\t}, function(){\r\n\r\n\t  \t\t\tvar isThreeDoubles = false;\r\n\r\n\t\t  \t\t//check for 3 doubles\r\n\t\t  \t\tvar doubles = Object.assign(this.state.doubles);\r\n\t\t  \t\tif(player.dice[0].number == player.dice[1].number){\r\n\t\t  \t\t\tif(doubles == 2){\r\n\t\t  \t\t\t\t//move furthest marker back to Start\r\n\t\t  \t\t\t\tvar mPos = getMostAdvancedPosition(player);\r\n\t\t  \t\t\t\tif(mPos != null){\r\n\r\n\t\t  \t\t\t\t\tthis.moveMarker(mPos, (player.player * (-1)));\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t  \t\t\t\tdoubles = 0;\r\n\t\t  \t\t\t\tisThreeDoubles = true;\r\n\r\n\t\t  \t\t\t}else{\r\n\t\t  \t\t\t\tdoubles++;\r\n\t\t  \t\t\t}\r\n\t\t  \t\t}else{\r\n\t\t  \t\t\tdoubles = 0;\r\n\t\t  \t\t}\r\n\r\n\t\t  \t\tthis.setState({\r\n\t\t  \t\t\tdoubles: doubles\r\n\t\t  \t\t});\r\n\r\n\t\t\t  \tif(isThreeDoubles || (!hasAnyValidMoves(players, turn) && player.dice[0].number != player.dice[1].number)){\r\n\t\t\t  \t\t\r\n\t\t\t  \t\t//no valid moves, show end turn button\r\n\t\t\t\t  \tthis.disableAllDice();\r\n\t\t\t  \t\tthis.setState({\r\n\t\t\t  \t\t\tturnComplete: true\r\n\t\t\t  \t\t});\r\n\r\n\t\t\t  \t}else if(!hasAnyValidMoves(players, turn) && player.dice[0].number == player.dice[1].number){\r\n\t\t\t  \t\t\r\n\t\t\t  \t\t//no valid moves on a double, set both dice to disabled without ending turn\r\n\t\t\t\t  \tthis.disableAllDice();\r\n\r\n\t\t\t  \t}\r\n\r\n\t\t\t  \t//otherwise, wait for next valid move\r\n\r\n\t  \t\t\tcallback();\r\n\r\n\t  \t\t}.bind(this));\r\n\r\n\t  \t}else{\r\n\t  \t\tcallback();\r\n\t  \t}\r\n  \t\t\r\n    };\r\n\r\n    this.disableAllDice = function(){\r\n\t  \tconst players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t\tplayers[turn-1].dice[0].active = false;\r\n\t  \tplayers[turn-1].dice[1].active = false;\r\n\r\n\t\t//if there is a bonus die\r\n\t\tif(typeof players[turn-1].dice[2] != \"undefined\"){\r\n\t\t\tplayers[turn-1].dice[2].active = false;\r\n\t\t}\r\n\t\tif(typeof players[turn-1].dice[3] != \"undefined\"){\r\n\t\t\tplayers[turn-1].dice[3].active = false;\r\n\t\t}\r\n\r\n\t\tthis.setState({\r\n\t\t\tplayers: players\r\n\t\t});\r\n\r\n    };\r\n\r\n    this.manageBlockades = function(){\r\n\r\n    \tconst players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t  \t//manage blockades\r\n  \t\tvar processedBlockades = [];\r\n\t\tvar x = players[turn-1].markers.length;\r\n\t\twhile (x--) {\r\n\r\n\t\t\tvar y = players[turn-1].markers.length;\r\n\t\t\twhile (y--) {\r\n\t  \t\t\t//if two different markers are on the same space, but not Start or Home\r\n\t\t\t    if( x!=y &&\r\n\t\t\t    \t[-1,-2,-3,-4,-11,-12,-13,-14].indexOf(players[turn-1].markers[x]) == -1 &&\r\n\t  \t\t\t\tplayers[turn-1].markers[x] == players[turn-1].markers[y] &&\r\n\t  \t\t\t\tprocessedBlockades.indexOf(players[turn-1].markers[x]) == -1\r\n\t\t\t\t){\r\n\t\t\t\t\t//check if the current blockade already exists in the list from the previous turn\r\n\t\t\t\t\tvar existingBlockadeIndex = null;\r\n\t\t\t\t\tvar z = players[turn-1].blockades.length;\r\n\t\t\t\t\twhile (z--) {\r\n\t\t\t\t\t\tif(players[turn-1].blockades[z].position == players[turn-1].markers[x]){\r\n\t\t\t\t\t\t\texistingBlockadeIndex = z;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(existingBlockadeIndex != null){\r\n\t\t\t\t\t\tplayers[turn-1].blockades[existingBlockadeIndex].duration += 1;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tplayers[turn-1].blockades.push({\r\n\t\t\t\t\t\t\tposition: players[turn-1].markers[x],\r\n\t  \t\t\t\t\t\tduration: 1\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//add to temp list so it is not processed twice\r\n\t  \t\t\t\tprocessedBlockades.push(players[turn-1].markers[x]);\r\n\t  \t\t\t}\r\n\t  \t\t}\r\n\r\n\t\t}\r\n\r\n\t  \t//remove blockades that no longer exist\r\n\t\tvar x = players[turn-1].blockades.length;\r\n\t\twhile (x--) {\r\n\t\t\t\r\n\t\t\tvar stillExists = false;\r\n\t\t\tvar y = processedBlockades.length;\r\n\t\t\twhile (y--) {\r\n\t\t\t\tif(processedBlockades[y] == players[turn-1].blockades[x].position){\r\n\t\t\t\t\tstillExists = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif(!stillExists){\r\n\t\t\t\tplayers[turn-1].blockades.splice(x, 1);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t  \t//blockade not broken after 3 turns\r\n\t\tvar x = players[turn-1].blockades.length;\r\n\t\twhile (x--) {\r\n\t\t\tif(players[turn-1].blockades[x].duration > 3){\r\n\t\t\t\t\r\n\t\t\t\t//move 1 of the markers back to Start\r\n\t  \t\t\tvar start = players[turn-1].blockades[x].position;\r\n\t  \t\t\tvar end = (players[turn-1].player * (-1));\r\n\r\n\t\t  \t\tfor(var r=0; r<players[turn-1].markers.length; r++){\r\n\t\t  \t\t\tif(players[turn-1].markers[r] == start){\r\n\t\t  \t\t\t\tplayers[turn-1].markers[r] = end;\r\n\t\t  \t\t\t\tbreak;\r\n\t\t  \t\t\t}\r\n\t\t  \t\t}\r\n\r\n\t\t\t\t//remove from blockades\r\n\t\t\t\tplayers[turn-1].blockades.splice(x, 1);\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n  \t\tthis.setState({\r\n\t\t\tplayers: players\r\n\t\t});\r\n\r\n    };\r\n\r\n    this.endTurn = function(){\r\n    \tconst players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t  \t//clear dice for current player\r\n\t  \tplayers[turn-1].dice = [];\r\n\r\n\t  \tthis.manageBlockades();\r\n\r\n\t  \tvar playersComplete = 0;\r\n\t  \twhile(true){\r\n\t  \t\t\r\n\t  \t\t//advance turn to next player\r\n\t\t  \tturn = (turn == players.length) ? 1 : turn + 1;\r\n\r\n\t  \t\t//check if new current player is finished, or not active\r\n\t\t  \tif(players[turn-1].finished || players[turn-1].human == null){\r\n\t\t  \t\tplayersComplete++;\r\n\t\t  \t}else{\r\n\t\t  \t\t//exit on the first player that still has markers on the board\r\n\t\t  \t\tbreak;\r\n\t\t  \t}\r\n\r\n\t  \t\tif(playersComplete == players.length){\r\n\r\n\t  \t\t\t//ALL PLAYERS COMPLETED\r\n\t\t\t\tthis.setState({\r\n\t\t\t\t\tgameState: 1,\r\n\t\t\t\t\tplayers: players\r\n\t\t\t\t});\r\n\r\n\t  \t\t\treturn;\r\n\t  \t\t}\r\n\r\n\t  \t}\r\n\r\n\t\tthis.setState({\r\n\t\t\tturn: turn,\r\n\t\t\tturnComplete: false,\r\n\t\t\tplayers: players\r\n\t\t}, function(){\r\n\r\n\t\t\t//if next turn is a CPU player, run AI\r\n\t\t\tif(players[turn-1].human == false){\r\n\r\n\t\t\t\tthis.startAiTurn();\r\n\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n    };\r\n\r\n    this.startAiTurn = function(){\r\n\r\n    \tthis.performAiRollAction(function(){\r\n\r\n    \t\tlet players = this.state.players.slice();\r\n\t\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t\t  \t//roll again if a double\r\n\t\t  \tif(players[turn-1].dice[0].number == players[turn-1].dice[1].number){\r\n\r\n\t\t\t\tthis.performAiRollAction(function(){\r\n\r\n\t\t\t\t\tplayers = this.state.players.slice();\r\n\r\n\t\t\t\t\t//roll again if a second double\r\n\t\t\t\t\tif(players[turn-1].dice[0].number == players[turn-1].dice[1].number){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tthis.performAiRollAction(function(){\r\n\r\n\t\t\t\t\t\t\tthis.endTurn();\r\n\r\n\t\t\t\t\t\t}.bind(this));\r\n\r\n\t\t\t\t\t}else{\r\n\t\t\t\t  \t\tthis.endTurn();\r\n\t\t\t\t  \t}\r\n\r\n\t\t\t\t}.bind(this));\r\n\r\n\t\t  \t}else{\r\n\t\t  \t\tthis.endTurn();\r\n\t\t  \t}\r\n\r\n    \t}.bind(this));\r\n\r\n    };\r\n\r\n    this.performAiRollAction = function(callback){\r\n\r\n    \t//roll dice\r\n    \tthis.rollDice(function(){\r\n\r\n\t\t\tthis.afterMoveCallback(function(){\r\n\r\n\t\t\t\tthis.disableAllDice();\r\n\r\n\t\t\t\tcallback();\r\n\r\n\t\t  \t}.bind(this));\r\n\r\n\t\t}.bind(this));\r\n\r\n    };\r\n\r\n    this.afterMoveCallback = function(callback){\r\n\r\n\t\t//pause for 0.5 second before each move\r\n    \tsetTimeout(function(){\r\n\r\n\t    \tconst players = this.state.players.slice();\r\n\t\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t    \tif(hasAnyValidMoves(players, turn)){\r\n\r\n    \t\t\tthis.loopOverActions(function(){\r\n    \t\t\t\t\r\n    \t\t\t\t//hide highlights after each move\r\n    \t\t\t\tthis.setState({\r\n\t\t\t\t  \t\tshowMoves: []\r\n\t\t\t\t  \t}, function(){\r\n\r\n\t\t\t  \t\t\tcallback();\r\n\r\n\t\t\t\t  \t});\r\n\r\n\t    \t\t}.bind(this));\r\n\r\n\t    \t}else{\r\n\t    \t\tcallback();\r\n\t    \t}\r\n\r\n    \t}.bind(this), 500);\r\n\r\n    };\r\n\r\n    this.loopOverActions = function(callback){\r\n\r\n    \tthis.breakBlockade(function(foundMove){\r\n\r\n\t\t\tif(!foundMove){\r\n\r\n\t\t\t\tthis.captureEnemy(function(foundMove){\r\n\r\n\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\tthis.moveUnsafeToSafe(function(foundMove){\r\n\r\n\t\t\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\t\t\tthis.moveOutOfStart(function(foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\tthis.moveIntoHome(function(foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.moveToSafeSpace(function(foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.moveAwayFromNearbyEnemy(function(foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.moveBehindNearestEnemy(function(foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!foundMove){\r\n\t\t\t\t\t\t\t\t\t\t    \t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.moveMostAdvanced(function(foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//no remaining valid moves\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!foundMove){\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcallback();\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}.bind(this));\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t\t\t}\r\n\t\t\t\t}.bind(this));\r\n\t\t\t}else{\r\n\t\t\t\tthis.afterMoveCallback(callback);\r\n\t\t\t}\r\n\t\t}.bind(this));\r\n\r\n    };\r\n\r\n    this.moveAiMarker = function(start, end, players, turn, cmdName){\r\n\r\n    \tconsole.log(\"CPU Player \" + turn + \": \" + cmdName);\r\n\r\n\t  \tthis.setState({\r\n\t  \t\tshowMoves: [end]\r\n\t  \t}, function(){\r\n\r\n\t  \t\tsetTimeout(function(){\r\n\r\n\t  \t\t\t//move marker to destination\r\n\t\t    \tfor(var r=0; r<players[turn-1].markers.length; r++){\r\n\t\t  \t\t\tif(players[turn-1].markers[r] == start){\r\n\t\t  \t\t\t\tplayers[turn-1].markers[r] = end;\r\n\t\t  \t\t\t\tbreak;\r\n\t\t  \t\t\t}\r\n\t\t  \t\t}\r\n\r\n\t\t\t\t//set used die (or dice) as disabled\r\n\t\t\t\tvar moveDistance = getDistance(start, end, players[turn-1].enters);\r\n\t\t\t\tvar usedDiceIndices = findUsedDice(players[turn-1].dice, moveDistance);\r\n\t\t\t\tfor(var d=0; d<usedDiceIndices.length;d++){\r\n\t\t\t\t\tplayers[turn-1].dice[usedDiceIndices[d]].active = false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//check if the player has completed all markers\r\n\t\t\t\tvar anyMarkersStillOnBoard = false;\r\n\t\t\t\tfor(var z=0;z<players[turn-1].markers.length;z++){\r\n\t\t\t\t\tif([-11,-12,-13,-14].indexOf(players[turn-1].markers[z]) == -1){\r\n\t\t\t\t\t\tanyMarkersStillOnBoard = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(!anyMarkersStillOnBoard){\r\n\t\t\t\t\tplayers[turn-1].finished = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.setState({\r\n\t\t\t\t\tplayers: players\r\n\t\t\t\t});\r\n\r\n\t\t\t}.bind(this), 500);\r\n\r\n\t\t});\r\n\r\n    };\r\n\r\n    this.breakBlockade = function(callback){\r\n\r\n\t  \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n    \t//check if any markers have a duration of 3, if so try to move one\r\n    \tvar blockadePosition = null;\r\n    \tfor(var x=0;x<players[turn-1].blockades.length;x++){\r\n\r\n    \t\tif(players[turn-1].blockades[x].duration == 3){\r\n\r\n    \t\t\tblockadePosition = players[turn-1].blockades[x].position;\r\n    \t\t\tbreak;\r\n\r\n    \t\t}\r\n\r\n    \t}\r\n\r\n    \tif(blockadePosition != null){\r\n\r\n    \t\tvar validMovesForMarker = getPossiblePositions(blockadePosition, players, turn);\r\n\r\n    \t\tif(validMovesForMarker.length > 0){\r\n\r\n\t    \t\tfor(var x=0; x<validMovesForMarker.length;x++){\r\n\t    \t\t\t\r\n\t    \t\t\t//remove blockade before passing players to move function\r\n\t    \t\t\tvar y = players[turn-1].blockades.length;\r\n\t    \t\t\twhile(y--){\r\n\r\n\t    \t\t\t\tif(players[turn-1].blockades[y].position == blockadePosition){\r\n\r\n\t    \t\t\t\t\tplayers[turn-1].blockades.splice(x, 1);\r\n\r\n\t    \t\t\t\t\tbreak;\r\n\r\n\t    \t\t\t\t}\r\n\r\n\t    \t\t\t}\r\n\r\n\t    \t\t\tthis.moveAiMarker(blockadePosition, validMovesForMarker[x], players, turn, 'breakBlockade');\r\n\t    \t\t\t\r\n\t    \t\t\tbreak;\r\n\r\n\t    \t\t}\r\n\t\t\t\t\r\n\t\t\t\tcallback(true);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n    \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n    this.captureEnemy = function(callback){\r\n\r\n\t  \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t  \tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n\r\n  \t\t//capture enemy\r\n\t  \tfor(var c=0; c<validMovesArray.length;c++){\r\n\t\t  \tfor(var a=0;a<players.length;a++){\r\n\t\t\t\tif(a != turn - 1){\r\n\t\t\t\t\tfor(var b=0; b<players[a].markers.length; b++){\r\n\t\t\t\t\t\tvar enemyMarkerPos = players[a].markers[b];\r\n\t\t\t\t\t\tif(validMovesArray[c].indexOf(enemyMarkerPos) != -1){\r\n\r\n\t\t\t\t\t\t\t//move enemy back to Start\r\n\t  \t\t\t\t\t\tthis.moveMarker(enemyMarkerPos, (players[a].player * (-1)));\r\n\r\n\t  \t\t\t\t\t\tvar playerMarkerPos = players[turn-1].markers[c];\r\n\r\n\t  \t\t\t\t\t\tthis.moveAiMarker(playerMarkerPos, enemyMarkerPos, players, turn, 'captureEnemy');\r\n\r\n\t\t\t\t\t\t\tthis.addBonusMove(20);\r\n\r\n\t\t\t\t\t\t\tcallback(true);\r\n\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t  \t}\r\n\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n    this.moveUnsafeToSafe = function(callback){\r\n\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t  \tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n\r\n\t  \tvar safePositions = getSafePositionsForTurn(players, turn);\r\n\r\n  \t\t//move from unsafe to safe space\r\n\t  \tfor(var c=0; c<validMovesArray.length;c++){\r\n\r\n  \t\t\t//if any marker is not on a safe space\r\n  \t\t\tif(safePositions.indexOf(players[turn-1].markers[c]) == -1){\r\n\r\n\t  \t\t\tfor(var b=0; b<safePositions.length; b++){\r\n\r\n\t  \t\t\t\t//and a safe space is a valid move for that marker\r\n\t\t  \t\t\tif(validMovesArray[c].indexOf(safePositions[b]) != -1){\r\n\r\n  \t\t\t\t\t\tvar safeDestination = safePositions[b];\r\n\r\n  \t\t\t\t\t\tthis.moveAiMarker(players[turn-1].markers[c], safeDestination, players, turn, 'moveUnsafeToSafe');\r\n\r\n\t\t\t\t\t\tcallback(true);\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t  \t\t\t}else{\r\n\r\n\t\t  \t\t\t\t//or if any team marker position is a valid move for another marker\r\n\t  \t\t\t\t\tfor(var a=0; a<players[turn-1].markers.length; a++){\r\n\t  \t\t\t\t\t\t\r\n\t  \t\t\t\t\t\tif(a!=c && validMovesArray[c].indexOf(players[turn-1].markers[a]) != -1){\r\n\t  \t\t\t\t\t\t\t\r\n\t  \t\t\t\t\t\t\tvar safeDestination = players[turn-1].markers[a];\r\n\r\n\t\t\t\t\t\t\t\tthis.moveAiMarker(players[turn-1].markers[c], safeDestination, players, turn, 'moveUnsafeToSafe');\r\n\r\n\t\t\t\t\t\t\t\tcallback(true);\r\n\t\t\t\t\t\t\t\treturn;\r\n\r\n\t  \t\t\t\t\t\t}\r\n\r\n\t  \t\t\t\t\t}\r\n\r\n\t\t  \t\t\t}\r\n\r\n\t  \t\t\t}\r\n\r\n\t  \t\t}\r\n\t  \t\t\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n    this.moveOutOfStart = function(callback){\r\n\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t  \tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n\r\n    \t//move out of Start\r\n\t  \tfor(var c=0; c<validMovesArray.length;c++){\r\n\r\n\t  \t\tlet playerEnterPos = players[turn-1].enters;\r\n\t  \t\tif(validMovesArray[c].indexOf(playerEnterPos) != -1){\r\n\r\n\t  \t\t\tvar playerMarkerPos = players[turn-1].markers[c];\r\n\r\n\t\t\t\tthis.moveAiMarker(playerMarkerPos, playerEnterPos, players, turn, 'moveOutOfStart');\r\n\r\n\t\t\t\tcallback(true);\r\n\t\t\t\treturn;\r\n\r\n\t  \t\t}\r\n\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n    this.moveIntoHome = function(callback){\r\n\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\t\t\r\n\t\tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n    \t\r\n    \t//move into Home\r\n\t  \tfor(var c=0; c<validMovesArray.length;c++){\r\n\r\n\t  \t\tlet playerHomePos = (turn * (-1)) - 10;\r\n\t  \t\tif(validMovesArray[c].indexOf(playerHomePos) != -1){\r\n\r\n\t  \t\t\tvar playerMarkerPos = players[turn-1].markers[c];\r\n\r\n\t\t\t\tthis.moveAiMarker(playerMarkerPos, playerHomePos, players, turn, 'moveIntoHome');\r\n\r\n    \t\t\tthis.addBonusMove(10);\r\n\r\n\t\t\t\tcallback(true);\r\n\r\n\t\t\t\treturn;\r\n\r\n\t  \t\t}\r\n\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n    this.moveToSafeSpace = function(callback){\r\n\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\r\n\t  \tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n\r\n\t  \tvar safePositions = getSafePositionsForTurn(players, turn);\r\n\r\n  \t\t//move from any space to a safe space\r\n\t  \tfor(var c=0; c<validMovesArray.length;c++){\r\n\r\n  \t\t\tfor(var b=0; b<safePositions.length; b++){\r\n\r\n  \t\t\t\t//if a ramp space or safe space is a valid move for a marker\r\n\t  \t\t\tif(validMovesArray[c].indexOf(safePositions[b]) != -1){\r\n\r\n\t\t\t\t\tvar safeDestination = safePositions[b];\r\n\r\n\t\t\t\t\tthis.moveAiMarker(players[turn-1].markers[c], safeDestination, players, turn, 'moveToSafeSpace');\r\n\r\n\t\t\t\t\tcallback(true);\r\n\t\t\t\t\treturn;\r\n\r\n\t  \t\t\t}else{\r\n\t  \t\t\t\t//or if any team marker position is a valid move for another marker\r\n  \t\t\t\t\tfor(var a=0; a<players[turn-1].markers.length; a++){\r\n  \t\t\t\t\t\t\r\n  \t\t\t\t\t\tif(a!=c && validMovesArray[c].indexOf(players[turn-1].markers[a]) != -1){\r\n  \t\t\t\t\t\t\t\r\n  \t\t\t\t\t\t\tvar safeDestination = players[turn-1].markers[a];\r\n\r\n\t\t\t\t\t\t\tthis.moveAiMarker(players[turn-1].markers[c], safeDestination, players, turn, 'moveToSafeSpace');\r\n\r\n\t\t\t\t\t\t\tcallback(true);\r\n\t\t\t\t\t\t\treturn;\r\n\r\n  \t\t\t\t\t\t}\r\n\r\n  \t\t\t\t\t}\r\n\r\n\t  \t\t\t}\r\n\r\n  \t\t\t}\r\n\t  \t\t\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n    this.moveAwayFromNearbyEnemy = function(callback){\r\n    \t\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\t\t\r\n\t  \tvar safePositions = getSafePositionsForTurn(players, turn);\r\n\r\n\t\tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\t//only get valid moves for markers that are not safe\r\n\t  \t\tif(safePositions.indexOf(m) == -1 && [-11,-12,-13,-14].indexOf(m) == -1){\r\n\r\n\t  \t\t\tvar markerHasEnemyBehind = false;\r\n\r\n\t  \t\t\tfor(var y=0;y<players.length;y++){\r\n\t  \t\t\t\tif(players[y].player != turn){\r\n\t  \t\t\t\t\t//for each enemy marker\r\n\t  \t\t\t\t\tfor(var z=0;z<players[y].markers.length;z++){\r\n\r\n\t  \t\t\t\t\t\t//check if the enemy marker has a player marker within 10 spaces\r\n\t  \t\t\t\t\t\tvar enemyMarkerPos = players[y].markers[z];\r\n\t  \t\t\t\t\t\tfor(var s=0;s<10;s++){\r\n\t  \t\t\t\t\t\t\t\r\n\t  \t\t\t\t\t\t\tenemyMarkerPos = manageIncrement(enemyMarkerPos, players[y].enters);\r\n\r\n\t  \t\t\t\t\t\t\tif(enemyMarkerPos == m){\r\n\r\n\t  \t\t\t\t\t\t\t\tmarkerHasEnemyBehind = true;\r\n\r\n\t  \t\t\t\t\t\t\t}\r\n\r\n\t  \t\t\t\t\t\t}\r\n\r\n\t  \t\t\t\t\t}\r\n\t  \t\t\t\t}\r\n\r\n\t  \t\t\t}\r\n\r\n\t  \t\t\tif(markerHasEnemyBehind){\r\n\t  \t\t\t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\t}else{\r\n\t\t  \t\t\tvalidMovesArray.push([]);\r\n\t\t  \t\t}\r\n\r\n\t  \t\t}else{\r\n\t  \t\t\tvalidMovesArray.push([]);\r\n\t  \t\t}\r\n\r\n\t  \t}\r\n    \t\r\n    \t//move away from nearby enemy\r\n\t  \tfor(var c=0; c<validMovesArray.length;c++){\r\n\r\n\t  \t\tif(validMovesArray[c].length > 0){\r\n\r\n  \t\t\t\tvar playerMarkerPos = players[turn-1].markers[c];\r\n\r\n\t\t\t\tthis.moveAiMarker(playerMarkerPos, validMovesArray[c][0], players, turn, 'moveAwayFromNearbyEnemy');\r\n\r\n\t\t\t\tcallback(true);\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n\r\n    };\r\n\r\n    this.moveBehindNearestEnemy = function(callback){\r\n    \t\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\t\t\r\n\t\tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n\r\n\t  \t//get player marker indices where there are enemies ahead\r\n\t  \tvar markersWithEnemyAhead = [];\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar playerMarkerPos = players[turn-1].markers[x];\r\n\t\t\tfor(var s=0;s<10;s++){\r\n\t\t\t\t\r\n\t\t\t\tvar hasEnemyAhead = false;\r\n\r\n\t\t\t\tplayerMarkerPos = manageIncrement(playerMarkerPos, players[turn-1].enters);\r\n\r\n\t\t\t\t//if the next space exists\r\n\t\t\t\tif(playerMarkerPos != null){\r\n\t\t\t\t\t\r\n\t\t\t\t\t//for each enemy player\r\n\t\t\t\t\tfor(var y=0; y<players.length;y++){\r\n\r\n\t\t\t\t\t\tif(players[turn-1].player != players[y].player){\r\n\r\n\t\t\t\t\t\t\t//for each enemy marker\r\n\t\t\t\t\t\t\tfor(var z=0; z<players[y].markers.length;z++){\r\n\r\n\t\t\t\t\t\t\t\tvar enemyMarkerPos = players[y].markers[z];\r\n\r\n\t\t\t\t\t\t\t\t//if the enemy is in the path and it is the first enemy found in the path\r\n\t\t\t\t\t\t\t\tif(playerMarkerPos == enemyMarkerPos && !hasEnemyAhead){\r\n\r\n\t\t\t\t\t\t\t\t\tmarkersWithEnemyAhead.push(x);\r\n\r\n\t\t\t\t\t\t\t\t\tvar a = validMovesArray[x].length;\r\n\t\t\t\t\t\t\t\t\twhile(a--){\r\n\r\n\t\t\t\t\t\t\t\t\t\tvar distToDest = getDistance(players[turn-1].markers[x], validMovesArray[x][a], players[turn-1].enters);\r\n\t\t\t\t\t\t\t\t\t\tvar distToEnemy = getDistance(players[turn-1].markers[x], enemyMarkerPos, players[turn-1].enters);\r\n\r\n\t\t\t\t\t\t\t\t\t\t//remove any destination from valid moves where there is an enemy in the path\r\n\t\t\t\t\t\t\t\t\t\tif(distToDest > distToEnemy){\r\n\t\t\t\t\t\t\t\t\t\t\tvalidMovesArray[x].splice(a, 1);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\thasEnemyAhead = true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}else{\r\n\r\n\t\t\t\t\t//if no space exists ahead, skip to next marker\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//make the first valid move of a marker with enemies ahead that does not require moving past an enemy\r\n\t\tfor(var a=0;a<markersWithEnemyAhead.length;a++){\r\n\r\n\t\t\tvar markerIndex = markersWithEnemyAhead[a];\r\n\t\t\tvar validMovesForMarker = validMovesArray[markerIndex];\r\n\t\t\tfor(var b=0; b<validMovesForMarker.length;b++){\r\n\r\n\t\t\t\tvar destPos = validMovesForMarker[b];\r\n\t\t\t\tvar playerMarkerPos = players[turn-1].markers[markerIndex];\r\n\r\n\t\t\t\tthis.moveAiMarker(playerMarkerPos, destPos, players, turn, 'moveBehindNearestEnemy');\r\n\r\n\t\t\t\tcallback(true);\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tcallback(false);\r\n\t\treturn;\r\n\r\n    };\r\n\r\n    this.moveMostAdvanced = function(callback){\r\n\r\n    \tlet players = this.state.players.slice();\r\n\t  \tlet turn = Object.assign(this.state.turn);\r\n\t\t\r\n\t\tlet validMovesArray = [];\r\n\r\n\t  \tfor(var x=0; x<players[turn-1].markers.length;x++){\r\n\r\n\t  \t\tvar m = players[turn-1].markers[x];\r\n\t  \t\tvalidMovesArray.push(getPossiblePositions(m, players, turn));\r\n\t  \t\t\r\n\t  \t}\r\n\r\n\t  \tvar orderedMarkerIndices = [];\r\n\t  \tvar mostAdvancedIndex = null;\r\n\r\n\t  \tfor(var n=0; n<players[turn-1].markers.length;n++){\r\n\r\n\t\t  \tvar longestDistance = -900;\r\n\t\t  \tfor(var m=0; m<players[turn-1].markers.length;m++){\r\n\t\t  \t\t\r\n\t\t  \t\t//only get distance of marker that is beyond the enter position\r\n\t\t  \t\tvar distanceFromStart = -1;\r\n\t\t  \t\tif(players[turn-1].markers[m] == players[turn-1].enters){\r\n\t\t  \t\t\tdistanceFromStart = 0;\r\n\t\t  \t\t}else if([-1,-2,-3,-4].indexOf(players[turn-1].markers[m]) == -1){\r\n\t\t  \t\t\tdistanceFromStart = getDistance(players[turn-1].enters, players[turn-1].markers[m], players[turn-1].enters);\r\n\t\t  \t\t}\r\n\t\t  \t\t\r\n\t\t  \t\tif(orderedMarkerIndices.indexOf(m) == -1 && longestDistance < distanceFromStart){\r\n\t\t\t\t\tlongestDistance = distanceFromStart;\r\n\t\t\t\t\tmostAdvancedIndex = m;\r\n\t\t  \t\t}\r\n\t\t  \t}\r\n\t  \t\torderedMarkerIndices.push(mostAdvancedIndex);\r\n\r\n\t\t}\r\n\r\n\t\tfor(var m=0; m<orderedMarkerIndices.length;m++){\r\n\r\n\t\t\tvar orderedMarkerPos = players[turn-1].markers[orderedMarkerIndices[m]];\r\n\t\t\tvar validMovesForOrderedMarker = validMovesArray[orderedMarkerIndices[m]];\r\n\r\n\t\t\tfor(var n=0; n<validMovesForOrderedMarker.length; n++){\r\n\r\n\t\t\t\tthis.moveAiMarker(orderedMarkerPos, validMovesForOrderedMarker[n], players, turn, 'moveMostAdvanced');\r\n\r\n\t\t\t\tcallback(true);\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t  \t}\r\n\r\n\t\tcallback(false);\r\n\t\treturn;\r\n    };\r\n\r\n  }\r\n\r\n  handleChangeConfigurePlayer(e){\r\n\r\n\t\tlet inputName = e.target.id.split('_');\r\n\r\n\t\tlet human = inputName[0] == 'p' ? true : (inputName[0] == 'cpu' ? false : null);\r\n\t\tlet pIndex = parseInt(inputName[1]) - 1;\r\n\r\n\t  \tconst players = this.state.players.slice();\r\n\t  \tplayers[pIndex].human = human;\r\n\r\n\t\tthis.setState({\r\n\t\t\tplayers: players\r\n\t\t});\r\n\r\n  }\r\n\r\n  handleClickStartGame(e){\r\n\t\t\r\n\t\t//find the first player and set the turn\r\n\t\tconst players = this.state.players.slice();\r\n\r\n\t\tlet activePlayerCount = 0;\r\n\t\tfor(var x=0; x<players.length;x++){\r\n\t\t\tif(players[x].human != null){\r\n\t\t\t\tactivePlayerCount++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//only start game if there are at least 2 players\r\n\t\tif(activePlayerCount > 1){\r\n\r\n\t\t\tlet turn = Object.assign(this.state.turn) - 1;\r\n\r\n\t\t\t//set game to start\r\n\t\t\tthis.setState({\r\n\t\t\t\tgameState: 0\r\n\t\t\t});\r\n\r\n\t\t  \twhile(true){\r\n\t\t  \t\t\r\n\t\t  \t\t//advance turn to next player\r\n\t\t\t  \tturn = (turn == players.length) ? 1 : turn + 1;\r\n\r\n\t\t  \t\t//set the next active player as the current turn\r\n\t\t\t  \tif(players[turn-1].human != null){\r\n\t\t\t  \t\tbreak;\r\n\t\t\t  \t}\r\n\r\n\t\t  \t}\r\n\r\n\t\t  \t//start first turn\r\n\t\t\tthis.setState({\r\n\t\t\t\tturn: turn,\r\n\t\t\t\tturnComplete: false\r\n\t\t\t}, function(){\r\n\r\n\t\t\t\tif(players[turn-1].human == false){\r\n\r\n\t\t\t\t\tthis.startAiTurn();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\t\t}\r\n\t  \t\r\n  }\r\n\r\n  \thandleClickEndTurn(e){\r\n\t\tthis.endTurn();\r\n  \t}\r\n\r\n  \thandleClickRollDice(e){\r\n  \t\tthis.rollDice(function(){\r\n\r\n  \t\t});\r\n  \t}\r\n\r\n  \t//move clicked marker out of the origin space and center under the mouse\r\n    handleMouseDownMarker(event){\r\n  \t\tconst markerElement = ReactDOM.findDOMNode(event.target);\r\n\r\n  \t\t//get the distance between the marker and the mouse\r\n\t    let shiftX = event.clientX - markerElement.getBoundingClientRect().left;\r\n\t    let shiftY = event.clientY - markerElement.getBoundingClientRect().top;\r\n\r\n\t    //get the distance between the marker and its parent\r\n\t    let distInsideX = markerElement.getBoundingClientRect().left - markerElement.parentNode.getBoundingClientRect().left;\r\n\t    let distInsideY = markerElement.getBoundingClientRect().top - markerElement.parentNode.getBoundingClientRect().top;\r\n\r\n\t    //set the marker to its equivalent position using absolute positioning inside its parent\r\n\t    var markerStyle = markerElement.currentStyle || window.getComputedStyle(markerElement);\r\n    \tmarkerElement.style.left = distInsideX - parseInt(markerStyle.marginLeft) + 'px';\r\n    \tmarkerElement.style.top = distInsideY - parseInt(markerStyle.marginTop) + 'px';\r\n\t    markerElement.style.position = 'absolute';\r\n\t    markerElement.style.zIndex = 5000;\r\n\t    markerElement.parentNode.style.zIndex = 5000;\r\n\t    markerElement.closest('.quadrant').style.zIndex = 5000;\r\n\r\n    \t//continually center marker under the mouse as it moves\r\n    \tdocument.onmousemove = function(e){\r\n\t\t\t//get the distance between the parent and the mouse\r\n\t    \tlet mouseX = e.clientX - markerElement.parentNode.getBoundingClientRect().left;\r\n\t    \tlet mouseY = e.clientY - markerElement.parentNode.getBoundingClientRect().top;\r\n\r\n\t    \t//move the marker to the same position as the mouse, relative to its parent\r\n\t    \tvar markerStyle = markerElement.currentStyle || window.getComputedStyle(markerElement);\r\n\t\t\tmarkerElement.style.left = mouseX - (markerElement.getBoundingClientRect().width / 2) - parseInt(markerStyle.marginLeft) + 'px';\r\n\t\t\tmarkerElement.style.top = mouseY - (markerElement.getBoundingClientRect().height / 2) - parseInt(markerStyle.marginTop) + 'px';\r\n    \t}\r\n    }\r\n\r\n    //stop the move listener, and drop the marker into the destination space or back in the origin space\r\n\thandleMouseUpMarker(event){\r\n  \t\tdocument.onmousemove = null;\r\n\r\n  \t\tconst markerElement = ReactDOM.findDOMNode(event.target);\r\n\r\n  \t\t//tokenindex is the last recorded position of the token\r\n    \tconst originPosition = parseInt(markerElement.getAttribute('tokenindex'));\r\n\t\tlet players = this.state.players.slice();\r\n\t\tconst turn = Object.assign(this.state.turn);\r\n\r\n        let validMoves = getPossiblePositions(originPosition, players, turn);\r\n\r\n\t    //capture the element below the marker\r\n\t    markerElement.style.visibility = \"hidden\";\r\n\t    let belowElement = document.elementFromPoint(event.clientX, event.clientY);\r\n\t    markerElement.style.visibility = null;\r\n\r\n\t    if (belowElement != null){\r\n\r\n\t    \tlet destinationElement = belowElement.closest('.space, .playerHome');\r\n\t    \tif(destinationElement != null){\r\n\r\n\t\t\t    let destinationPosition = parseInt(destinationElement.getAttribute('positionindex'));\r\n\r\n\t\t\t    //if space is a valid move\r\n\t\t\t    if(validMoves.indexOf(destinationPosition) != -1){\r\n\r\n\t\t\t\t\tfor(var u=0;u<players.length; u++){\r\n\t\t\t    \t\t//if not the current player\r\n\t\t\t    \t\tif(players[u].player != turn){\r\n\t\t\t\t\t    \tfor(var w=0;w<players[u].markers.length; w++){\r\n\t\t\t\t\t    \t\t//if enemy marker is on destination space\r\n\t\t\t\t\t\t  \t\tif(players[u].markers[w] == destinationPosition){\r\n\t\t\t\t\t\t  \t\t\t//send enemy marker back to Start\r\n\t\t\t\t\t\t  \t\t\tthis.moveMarker(destinationPosition, (players[u].player * (-1)));\r\n\t\t\t\t\t\t  \t\t\tthis.addBonusMove(20);\r\n\t\t\t\t\t\t  \t\t\tbreak;\r\n\t\t\t\t\t\t  \t\t}\r\n\t\t\t\t\t\t  \t}\r\n\t\t\t\t\t  \t}\r\n\t\t\t\t\t}\r\n\r\n\t\t        \t//move marker element into destination space\r\n\t\t  \t\t\tthis.moveMarker(originPosition, destinationPosition);\r\n\t\t\t\t\tmarkerElement.style.position = null;\r\n\t\t\t\t\tmarkerElement.style.zIndex = null;\r\n\t\t\t\t    markerElement.style.left = null;\r\n\t\t\t\t    markerElement.style.top = null;\r\n\t    \t\t\tmarkerElement.parentNode.style.zIndex = null;\r\n\t    \t\t\tmarkerElement.closest('.quadrant').style.zIndex = null;\r\n\r\n\t\t\t\t  \tplayers = this.state.players.slice();\r\n\r\n\t\t\t\t\t//set used die (or dice) as disabled\r\n\t\t  \t\t\tvar moveDistance = getDistance(originPosition, destinationPosition, players[turn-1].enters);\r\n\t\t  \t\t\tvar usedDiceIndices = findUsedDice(players[turn-1].dice, moveDistance);\r\n\t\t  \t\t\tfor(var b=0; b<usedDiceIndices.length;b++){\r\n\t\t\t\t\t\tplayers[turn-1].dice[usedDiceIndices[b]].active = false;\r\n\t\t  \t\t\t}\r\n\r\n\t\t\t\t\tthis.setState({\r\n\t\t\t\t\t\tplayers: players\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t//if marker made it to Home\r\n\t\t\t\t\tif((players[turn-1].player * (-1)) - 10 == destinationPosition){\r\n\t\t\t\t\t\tthis.addBonusMove(10);\r\n\r\n\t\t\t\t\t\t//check if the player has completed all markers\r\n\t\t\t\t\t\tvar anyMarkersStillOnBoard = false;\r\n\t\t\t\t\t\tplayers = this.state.players.slice();\r\n\t\t\t\t\t\tfor(var z=0;z<players[turn-1].markers.length;z++){\r\n\t\t\t\t\t\t\tif([-11,-12,-13,-14].indexOf(players[turn-1].markers[z]) == -1){\r\n\t\t\t\t\t\t\t\tanyMarkersStillOnBoard = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(!anyMarkersStillOnBoard){\r\n\t\t\t\t\t\t\tplayers[turn-1].finished = true;\r\n\t\t\t\t\t\t\tthis.setState({\r\n\t\t\t\t\t\t\t\tplayers: players\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t  \t\t\t}\r\n\r\n\t\t  \t\t\t//if there are no valid moves and it was NOT a double\r\n\t\t\t\t  \tplayers = this.state.players.slice();\r\n\t\t  \t\t\tif(!hasAnyValidMoves(players, turn) &&\r\n\t\t  \t\t\t\tplayers[turn-1].dice[0].number != players[turn-1].dice[1].number){\r\n\r\n\t\t  \t\t\t\t//clear dice and end turn\r\n\t\t  \t\t\t\tthis.disableAllDice();\r\n\t\t\t\t  \t\tthis.setState({\r\n\t\t\t\t  \t\t\tturnComplete: true\r\n\t\t\t\t  \t\t});\r\n\r\n\t\t  \t\t\t}else if(!hasAnyValidMoves(players, turn) &&\r\n\t\t  \t\t\t\tplayers[turn-1].dice[0].number == players[turn-1].dice[1].number){\r\n\t\t  \t\t\t\t\r\n\t\t  \t\t\t\t//if there are no valid moves and it WAS a double\r\n\t\t  \t\t\t\t//clear dice without ending turn\r\n\t\t  \t\t\t\tthis.disableAllDice();\r\n\r\n\t\t  \t\t\t}\r\n\r\n\t\t  \t\t\t//otherwise, wait for next valid move\r\n\t\t\t  \t\tthis.setState({\r\n\t\t\t  \t\t\tshowMoves: []\r\n\t\t\t  \t\t});\r\n\r\n\t\t\t  \t\treturn;\r\n\t\t\t    }\r\n\t    \t}\r\n\t    }\r\n\r\n\t    //invalid move, remove movement styles and show valid moves\r\n    \tthis.setState({\r\n  \t\t\tshowMoves: validMoves\r\n  \t\t});\r\n\r\n    \tmarkerElement.style.position = null;\r\n    \tmarkerElement.style.zIndex = null;\r\n        markerElement.style.left = null;\r\n        markerElement.style.top = null;\r\n\t\tmarkerElement.parentNode.style.zIndex = null;\r\n\t\tmarkerElement.closest('.quadrant').style.zIndex = null;\r\n\r\n\t}\r\n\r\n    render() {\r\n\t    return (\r\n\t    \t<div id=\"boardContainer\">\r\n\t          <Board\r\n\t          \tgameState={this.state.gameState}\r\n\t          \tturn={this.state.turn}\r\n\t          \tonMouseDownMarker={(e) => this.handleMouseDownMarker(e)}\r\n\t          \tonMouseUpMarker={(e) => this.handleMouseUpMarker(e)}\r\n\t          \tonClickStartGame={(e) => this.handleClickStartGame(e)}\r\n\t          \tonChangeConfigurePlayer={(e) => this.handleChangeConfigurePlayer(e)}\r\n\t          \tonClickRollDice={(e) => this.handleClickRollDice(e)}\r\n\t          \tonClickEndTurn={(e) => this.handleClickEndTurn(e)}\r\n\t          \tturnComplete={this.state.turnComplete}\r\n\t          \tshowMoves={this.state.showMoves}\r\n\t          \tplayers={this.state.players}\r\n\t          />\r\n          </div>\r\n\t    );\r\n    }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n  <Game />,\r\n  document.getElementById('root')\r\n);\r\n\r\nfunction hasAnyValidMoves(players, turn){\r\n\tconst player = players[turn-1];\r\n\tvar anyMoves = false;\r\n\r\n\t//check for legal moves\r\n\tfor(var t=0; t<player.markers.length; t++){\r\n\t\tvar positionArray = getPossiblePositions(player.markers[t], players, turn);\r\n\r\n\t\tif(positionArray.length > 0){\r\n\t\t\tanyMoves = true;\r\n\t\t}\r\n\t}\r\n\treturn anyMoves;\r\n}\r\n\r\nfunction isSpaceBlocked(space, players){\r\n\r\n  \tvar blocked = false;\r\n  \t//for each player\r\n  \tfor(var x=0;x<players.length;x++){\r\n  \t\tvar onSpace = 0;\r\n  \t\t//count the number of markers on the space\r\n  \t\tfor(var y=0;y<players[x].markers.length;y++){\r\n\t  \t\tif(players[x].markers[y] == space){\r\n\t\t\t\tonSpace++;\r\n\t  \t\t}\r\n  \t\t}\r\n  \t\t//if there are two markers, the space is blocked\r\n  \t\tif(onSpace == 2){\r\n  \t\t\tblocked = true;\r\n  \t\t}\r\n  \t}\r\n\r\n  \treturn blocked;\r\n}\r\n\r\nfunction manageIncrement(x, enterPos){\r\n\tif(x == null){\r\n\t\treturn x;\r\n\t}\r\n  \tif(x==67){\r\n  \t\tif(enterPos == 4){\r\n  \t\t\t//increment up ramp\r\n  \t\t\treturn x + 100;\r\n  \t\t}else {\r\n  \t\t\t//increment back to 0\r\n  \t\t\treturn 0;\r\n  \t\t}\r\n  \t} else if((x==16 && enterPos==21) || (x==33 && enterPos==38) || (x==50 && enterPos==55) || (x > 67 && x < 716)){\r\n  \t\t//increment up non-looping ramps\r\n  \t\treturn x + 100;\r\n  \t}else if(x==716){\r\n  \t\t//increment into Home\r\n  \t\treturn -14;\r\n  \t}else if(x==733){\r\n  \t\t//increment into Home\r\n  \t\treturn -11;\r\n  \t}else if(x==750){\r\n  \t\t//increment into Home\r\n  \t\treturn -12;\r\n  \t}else if(x==767){\r\n  \t\t//increment into Home\r\n  \t\treturn -13;\r\n  \t}else if([-11,-12,-13,-14].indexOf(x) != -1){\r\n  \t\t//already incremented to Home\r\n  \t\treturn null;\r\n  \t}else if([-1,-2,-3,-4].indexOf(x) != -1){\r\n  \t\t//at Start\r\n  \t\treturn enterPos;\r\n  \t}else{\r\n  \t\t//regular increment\r\n  \t\treturn x + 1;\r\n  \t}\r\n}\r\n\r\nfunction getDestination(start, moves, enterPos){\r\n  \tfor(var x=0;x<moves;x++){\r\n  \t\tstart = manageIncrement(start, enterPos);\r\n  \t}\r\n  \treturn start;\r\n}\r\n\r\nfunction isPathBlocked(start, end, enterPos, players){\r\n  \t//advance through each space in the move path\r\n\twhile(start != end){\r\n\t\tif(start == null){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t//increment before checking in case the start space is from a blocked space\r\n\t\tstart = manageIncrement(start, enterPos);\r\n\t\tif([-11,-12,-13,-14].indexOf(start) != -1){\r\n\t\t\t//the Home space is never blocked\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif(isSpaceBlocked(start, players)){\r\n  \t\t\t//exit if a blocked space is found in path\r\n  \t\t\treturn true;\r\n  \t\t}\r\n  \t}\r\n  \treturn false;\r\n}\r\n\r\nfunction getPossiblePositions(startPos, players, turn){\r\n\r\n  \tvar player = players[turn-1];\r\n  \tvar possiblePositions = [];\r\n\r\n\tif([-1,-2,-3,-4].indexOf(startPos) != -1){\r\n\t\t//marker is at Start\r\n\t\tif(isSpaceBlocked(player.enters, players)){\r\n\t\t\treturn [];\r\n\t\t}else{\r\n\t\t\tif((!player.dice[0].active || player.dice[0].number != 5) &&\r\n\t\t\t\t(!player.dice[1].active || player.dice[1].number != 5)){\r\n\t\t\t\t//if no 5 is rolled\r\n\t\t\t\treturn [];\r\n\t\t\t}else{\r\n\t\t\t\t//only use one 5 to enter if it is a double\r\n\t\t\t\tlet fiveUsedToEnter = false;\r\n\t\t\t\tfor(var x=0;x<player.dice.length;x++){\r\n\t\t\t\t\tif(player.dice[x].active){\r\n\t\t\t\t\t\tif(player.dice[x].number == 5 && !fiveUsedToEnter){\r\n\t\t\t\t\t\t\tfiveUsedToEnter = true;\r\n\t\t\t\t\t\t\tpossiblePositions.push(player.enters);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tvar dest = player.enters + player.dice[x].number;\r\n\t\t\t\t\t\t\tif(!isPathBlocked(player.enters, dest, player.enters, players)){\r\n\t\t\t\t\t\t\t\tpossiblePositions.push(dest);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}else if([-11,-12,-13,-14].indexOf(startPos) != -1){\r\n\t\t//marker has reached Home\r\n\t\treturn [];\r\n\t}else{\r\n\t\t//somewhere on the board\r\n\t\tconst dice = player.dice.slice();\r\n\t\tlet diceMoves = [];\r\n\r\n\t\t//get an array of active dice (max 2)\r\n\t\tfor(var x=0; x<dice.length; x++){\r\n\t\t\tif(dice[x].active){\r\n\t\t\t\tdiceMoves.push(dice[x]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(diceMoves.length > 1){\r\n\t\t\tdiceMoves.push({\r\n\t\t\t\tnumber: diceMoves[0].number + diceMoves[1].number,\r\n\t\t\t\tactive: true\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfor(var a=0;a<diceMoves.length;a++){\r\n\t\t\tif(diceMoves[a].active){\r\n\t\t\t\tvar dest = getDestination(startPos, diceMoves[a].number, player.enters);\r\n\t\t\t\tif(dest != null && !isPathBlocked(startPos, dest, player.enters, players)){\r\n\t\t\t\t\tpossiblePositions.push(dest);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//out of all possiblePositions, remove safe spaces that have enemy markers\r\n\tvar b = possiblePositions.length;\r\n\twhile (b--) {\r\n\t\t//if the destination is a safe space, but not the player's Start space\r\n\t\tif(possiblePositions[b] != player.enters && [4,11,16,21,28,33,38,45,50,55,62,67].indexOf(possiblePositions[b]) != -1){\r\n\t\t\t//for each enemy player\r\n\t\t\tfor(var c=0;c<players.length;c++){\r\n\t\t\t\tif(players[c].player != turn){\r\n\t\t\t\t\t//for each enemy marker\r\n\t\t\t\t\tfor(var d=0; d < players[c].markers.length;d++){\r\n\t\t\t\t\t\t//if a marker is on the destination\r\n\t\t\t\t\t\tif(players[c].markers[d] == possiblePositions[b]){\r\n\t\t\t\t\t\t\t//remove from possible positions\r\n\t\t\t\t\t\t\tpossiblePositions.splice(b, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn possiblePositions;\r\n}\r\n\r\nfunction getMostAdvancedPosition(player){\r\n  \tvar space = null;\r\n  \tvar distanceFromStart = 0;\r\n\tfor(var z=0;z<player.markers.length;z++){\r\n\t\t//skip markers at Start and Home\r\n\t\tif([-11,-12,-13,-14].indexOf(player.markers[z]) == -1 && [-1,-2,-3,-4].indexOf(player.markers[z]) == -1){\r\n\t\t\tvar curDistance = getDistance(player.enters, player.markers[z], player.enters);\r\n\t\t\tif(distanceFromStart < curDistance){\r\n\t\t\t\tdistanceFromStart = curDistance;\r\n\t\t\t\t//get the space of the marker that is the greatest distance from start\r\n\t\t\t\tspace = player.markers[z];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn space;\r\n}\r\n\r\nfunction getDistance(start, end, enterPos){\r\n  \tvar distance = 0;\r\n  \twhile(start != end){\r\n  \t\tvar fromPosition = start;\r\n\t\tstart = manageIncrement(start, enterPos);\r\n\t\tif([-1,-2,-3,-4].indexOf(fromPosition) != -1){\r\n\t\t\t//count 5 dice space when entering\r\n\t\t\tdistance += 5;\r\n\t\t}else{\r\n\t\t\t//count 1 dice space\r\n\t\t\tdistance++;\r\n\t\t}\r\n  \t}\r\n  \treturn distance;\r\n}\r\n\r\nfunction findUsedDice(dice, moveDistance){\r\n\r\n\tfor(var b=0; b<dice.length;b++){\r\n\t\tif(dice[b].active && dice[b].number == moveDistance){\r\n\t\t\t//if one die equals the move\r\n\t\t\treturn [b];\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(var b=0; b<dice.length;b++){\r\n\t\tif(dice[b].active){\r\n\t\t\tfor(var c=0; c<dice.length;c++){\r\n\t\t\t\tif(b != c && dice[c].active && (dice[b].number + dice[c].number) == moveDistance){\r\n\t\t\t\t\t//if two dice equal the move\r\n\t\t\t\t\treturn [b,c];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn [];\r\n}\r\n\r\nfunction getMarkersToRender(players, spacePosition){\r\n\tlet markersToRender = [];\r\n\tfor(var x=0; x < players.length; x++){\r\n\t\t//prevent rendering markers for inactive players\r\n\t\tif(players[x].human != null){\r\n\t\t\tfor(var y=0; y < players[x].markers.length; y++){\r\n\t\t\t\tif(players[x].markers[y] == spacePosition){\r\n\t\t\t\t\tmarkersToRender.push(players[x].player);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn markersToRender;\r\n}\r\n\r\n\r\nfunction getSafePositionsForTurn(players, turn){\r\n\r\n  \tconst safePositions = [4,11,16,21,28,33,38,45,50,55,62,67,-1,-2,-3,-4];\r\n\r\n  \tfor(var y=0;y<players.length;y++){\r\n  \t\t//for each enemy player\r\n  \t\tif(players[y].player != turn){\r\n\t\t  \tfor(var z=0;z<players[y].markers.length;z++){\r\n\t\t  \t\t//if the player has a marker at Start\r\n\t\t  \t\tif([-1,-2,-3,-4].indexOf(players[y].markers[z]) != -1){\r\n\t\t  \t\t\t//remove the enter space from safe spaces\r\n\t\t  \t\t\tvar indexToRemove = safePositions.indexOf(players[y].enters);\r\n\t\t  \t\t\tif(indexToRemove != -1){\r\n\t\t  \t\t\t\tsafePositions.splice(indexToRemove, 1);\r\n\t\t  \t\t\t}\r\n\t\t  \t\t}\r\n\t\t  \t}\r\n\t  \t}\r\n\t}\r\n\r\n  \tconst ramps = [\r\n  \t\t[67,167,267,367,467,567,667,767],\r\n  \t\t[16,116,216,316,416,516,616,716],\r\n  \t\t[33,133,233,333,433,533,633,733],\r\n  \t\t[50,150,250,350,450,550,650,750]\r\n  \t];\r\n\r\n  \t//add each ramp position for the current player\r\n  \tfor(var x=0;x<ramps[turn-1].length;x++){\r\n  \t\tsafePositions.push(ramps[turn-1][x]);\r\n  \t}\r\n\r\n\treturn safePositions;\r\n}\r\n",{"ruleId":"151","severity":1,"message":"152","line":6,"column":4,"nodeType":"153","messageId":"154","endLine":8,"endColumn":5},{"ruleId":"151","severity":1,"message":"152","line":41,"column":4,"nodeType":"153","messageId":"154","endLine":43,"endColumn":5},{"ruleId":"155","severity":1,"message":"156","line":54,"column":52,"nodeType":"157","messageId":"158","endLine":54,"endColumn":54},{"ruleId":"155","severity":1,"message":"156","line":54,"column":91,"nodeType":"157","messageId":"158","endLine":54,"endColumn":93},{"ruleId":"151","severity":1,"message":"152","line":73,"column":4,"nodeType":"153","messageId":"154","endLine":75,"endColumn":5},{"ruleId":"155","severity":1,"message":"159","line":82,"column":93,"nodeType":"157","messageId":"158","endLine":82,"endColumn":95},{"ruleId":"151","severity":1,"message":"152","line":98,"column":4,"nodeType":"153","messageId":"154","endLine":100,"endColumn":5},{"ruleId":"155","severity":1,"message":"156","line":128,"column":14,"nodeType":"157","messageId":"158","endLine":128,"endColumn":16},{"ruleId":"155","severity":1,"message":"156","line":147,"column":12,"nodeType":"157","messageId":"158","endLine":147,"endColumn":14},{"ruleId":"155","severity":1,"message":"156","line":148,"column":9,"nodeType":"157","messageId":"158","endLine":148,"endColumn":11},{"ruleId":"155","severity":1,"message":"156","line":154,"column":31,"nodeType":"157","messageId":"158","endLine":154,"endColumn":33},{"ruleId":"155","severity":1,"message":"156","line":154,"column":60,"nodeType":"157","messageId":"158","endLine":154,"endColumn":62},{"ruleId":"155","severity":1,"message":"156","line":159,"column":26,"nodeType":"157","messageId":"158","endLine":159,"endColumn":28},{"ruleId":"155","severity":1,"message":"156","line":159,"column":46,"nodeType":"157","messageId":"158","endLine":159,"endColumn":48},{"ruleId":"155","severity":1,"message":"156","line":159,"column":65,"nodeType":"157","messageId":"158","endLine":159,"endColumn":67},{"ruleId":"155","severity":1,"message":"159","line":163,"column":84,"nodeType":"157","messageId":"158","endLine":163,"endColumn":86},{"ruleId":"155","severity":1,"message":"156","line":182,"column":31,"nodeType":"157","messageId":"158","endLine":182,"endColumn":33},{"ruleId":"155","severity":1,"message":"156","line":262,"column":37,"nodeType":"157","messageId":"158","endLine":262,"endColumn":39},{"ruleId":"155","severity":1,"message":"159","line":268,"column":72,"nodeType":"157","messageId":"158","endLine":268,"endColumn":74},{"ruleId":"155","severity":1,"message":"156","line":296,"column":37,"nodeType":"157","messageId":"158","endLine":296,"endColumn":39},{"ruleId":"155","severity":1,"message":"156","line":325,"column":108,"nodeType":"157","messageId":"158","endLine":325,"endColumn":110},{"ruleId":"155","severity":1,"message":"156","line":325,"column":137,"nodeType":"157","messageId":"158","endLine":325,"endColumn":139},{"ruleId":"155","severity":1,"message":"156","line":329,"column":29,"nodeType":"157","messageId":"158","endLine":329,"endColumn":31},{"ruleId":"155","severity":1,"message":"156","line":329,"column":58,"nodeType":"157","messageId":"158","endLine":329,"endColumn":60},{"ruleId":"155","severity":1,"message":"156","line":351,"column":24,"nodeType":"157","messageId":"158","endLine":351,"endColumn":26},{"ruleId":"155","severity":1,"message":"156","line":351,"column":30,"nodeType":"157","messageId":"158","endLine":351,"endColumn":32},{"ruleId":"155","severity":1,"message":"156","line":352,"column":16,"nodeType":"157","messageId":"158","endLine":352,"endColumn":18},{"ruleId":"155","severity":1,"message":"156","line":352,"column":22,"nodeType":"157","messageId":"158","endLine":352,"endColumn":24},{"ruleId":"155","severity":1,"message":"156","line":357,"column":10,"nodeType":"157","messageId":"158","endLine":357,"endColumn":12},{"ruleId":"155","severity":1,"message":"156","line":362,"column":16,"nodeType":"157","messageId":"158","endLine":362,"endColumn":18},{"ruleId":"155","severity":1,"message":"156","line":367,"column":16,"nodeType":"157","messageId":"158","endLine":367,"endColumn":18},{"ruleId":"155","severity":1,"message":"156","line":372,"column":16,"nodeType":"157","messageId":"158","endLine":372,"endColumn":18},{"ruleId":"151","severity":1,"message":"152","line":391,"column":3,"nodeType":"153","messageId":"154","endLine":393,"endColumn":4},{"ruleId":"155","severity":1,"message":"156","line":405,"column":15,"nodeType":"157","messageId":"158","endLine":405,"endColumn":17},{"ruleId":"155","severity":1,"message":"156","line":405,"column":23,"nodeType":"157","messageId":"158","endLine":405,"endColumn":25},{"ruleId":"155","severity":1,"message":"156","line":405,"column":32,"nodeType":"157","messageId":"158","endLine":405,"endColumn":34},{"ruleId":"155","severity":1,"message":"156","line":483,"column":32,"nodeType":"157","messageId":"158","endLine":483,"endColumn":34},{"ruleId":"155","severity":1,"message":"156","line":524,"column":27,"nodeType":"157","messageId":"158","endLine":524,"endColumn":29},{"ruleId":"155","severity":1,"message":"156","line":545,"column":32,"nodeType":"157","messageId":"158","endLine":545,"endColumn":34},{"ruleId":"155","severity":1,"message":"156","line":546,"column":19,"nodeType":"157","messageId":"158","endLine":546,"endColumn":21},{"ruleId":"155","severity":1,"message":"159","line":569,"column":87,"nodeType":"157","messageId":"158","endLine":569,"endColumn":89},{"ruleId":"155","severity":1,"message":"156","line":577,"column":74,"nodeType":"157","messageId":"158","endLine":577,"endColumn":76},{"ruleId":"155","severity":1,"message":"159","line":630,"column":13,"nodeType":"157","messageId":"158","endLine":630,"endColumn":15},{"ruleId":"155","severity":1,"message":"156","line":631,"column":75,"nodeType":"157","messageId":"158","endLine":631,"endColumn":77},{"ruleId":"155","severity":1,"message":"156","line":632,"column":35,"nodeType":"157","messageId":"158","endLine":632,"endColumn":37},{"ruleId":"155","severity":1,"message":"156","line":633,"column":63,"nodeType":"157","messageId":"158","endLine":633,"endColumn":65},{"ruleId":"155","severity":1,"message":"156","line":639,"column":48,"nodeType":"157","messageId":"158","endLine":639,"endColumn":50},{"ruleId":"160","severity":1,"message":"161","line":661,"column":7,"nodeType":"162","messageId":"163","endLine":661,"endColumn":8},{"ruleId":"160","severity":1,"message":"164","line":665,"column":8,"nodeType":"162","messageId":"163","endLine":665,"endColumn":9},{"ruleId":"155","severity":1,"message":"156","line":667,"column":30,"nodeType":"157","messageId":"158","endLine":667,"endColumn":32},{"ruleId":"160","severity":1,"message":"161","line":679,"column":7,"nodeType":"162","messageId":"163","endLine":679,"endColumn":8},{"ruleId":"155","severity":1,"message":"156","line":688,"column":38,"nodeType":"157","messageId":"158","endLine":688,"endColumn":40},{"ruleId":"155","severity":1,"message":"156","line":719,"column":19,"nodeType":"157","messageId":"158","endLine":719,"endColumn":21},{"ruleId":"155","severity":1,"message":"156","line":729,"column":25,"nodeType":"157","messageId":"158","endLine":729,"endColumn":27},{"ruleId":"155","severity":1,"message":"156","line":749,"column":29,"nodeType":"157","messageId":"158","endLine":749,"endColumn":31},{"ruleId":"155","severity":1,"message":"156","line":767,"column":40,"nodeType":"157","messageId":"158","endLine":767,"endColumn":42},{"ruleId":"155","severity":1,"message":"156","line":774,"column":40,"nodeType":"157","messageId":"158","endLine":774,"endColumn":42},{"ruleId":"155","severity":1,"message":"156","line":936,"column":38,"nodeType":"157","messageId":"158","endLine":936,"endColumn":40},{"ruleId":"155","severity":1,"message":"156","line":952,"column":63,"nodeType":"157","messageId":"158","endLine":952,"endColumn":65},{"ruleId":"155","severity":1,"message":"156","line":979,"column":48,"nodeType":"157","messageId":"158","endLine":979,"endColumn":50},{"ruleId":"160","severity":1,"message":"161","line":994,"column":16,"nodeType":"162","messageId":"163","endLine":994,"endColumn":17},{"ruleId":"155","severity":1,"message":"156","line":1000,"column":51,"nodeType":"157","messageId":"158","endLine":1000,"endColumn":53},{"ruleId":"155","severity":1,"message":"159","line":1043,"column":10,"nodeType":"157","messageId":"158","endLine":1043,"endColumn":12},{"ruleId":"155","severity":1,"message":"159","line":1046,"column":53,"nodeType":"157","messageId":"158","endLine":1046,"endColumn":55},{"ruleId":"155","severity":1,"message":"156","line":1092,"column":59,"nodeType":"157","messageId":"158","endLine":1092,"endColumn":61},{"ruleId":"155","severity":1,"message":"159","line":1097,"column":56,"nodeType":"157","messageId":"158","endLine":1097,"endColumn":58},{"ruleId":"155","severity":1,"message":"159","line":1111,"column":14,"nodeType":"157","messageId":"158","endLine":1111,"endColumn":16},{"ruleId":"155","severity":1,"message":"159","line":1111,"column":76,"nodeType":"157","messageId":"158","endLine":1111,"endColumn":78},{"ruleId":"160","severity":1,"message":"165","line":1113,"column":15,"nodeType":"162","messageId":"163","endLine":1113,"endColumn":30},{"ruleId":"155","severity":1,"message":"159","line":1154,"column":52,"nodeType":"157","messageId":"158","endLine":1154,"endColumn":54},{"ruleId":"155","severity":1,"message":"159","line":1189,"column":51,"nodeType":"157","messageId":"158","endLine":1189,"endColumn":53},{"ruleId":"155","severity":1,"message":"159","line":1231,"column":55,"nodeType":"157","messageId":"158","endLine":1231,"endColumn":57},{"ruleId":"155","severity":1,"message":"159","line":1244,"column":13,"nodeType":"157","messageId":"158","endLine":1244,"endColumn":15},{"ruleId":"155","severity":1,"message":"159","line":1244,"column":75,"nodeType":"157","messageId":"158","endLine":1244,"endColumn":77},{"ruleId":"160","severity":1,"message":"165","line":1246,"column":14,"nodeType":"162","messageId":"163","endLine":1246,"endColumn":29},{"ruleId":"155","severity":1,"message":"156","line":1280,"column":34,"nodeType":"157","messageId":"158","endLine":1280,"endColumn":36},{"ruleId":"155","severity":1,"message":"156","line":1280,"column":72,"nodeType":"157","messageId":"158","endLine":1280,"endColumn":74},{"ruleId":"155","severity":1,"message":"159","line":1285,"column":29,"nodeType":"157","messageId":"158","endLine":1285,"endColumn":31},{"ruleId":"155","severity":1,"message":"156","line":1295,"column":29,"nodeType":"157","messageId":"158","endLine":1295,"endColumn":31},{"ruleId":"160","severity":1,"message":"161","line":1357,"column":13,"nodeType":"162","messageId":"163","endLine":1357,"endColumn":14},{"ruleId":"155","severity":1,"message":"159","line":1372,"column":33,"nodeType":"157","messageId":"158","endLine":1372,"endColumn":35},{"ruleId":"155","severity":1,"message":"156","line":1380,"column":28,"nodeType":"157","messageId":"158","endLine":1380,"endColumn":30},{"ruleId":"160","severity":1,"message":"166","line":1419,"column":11,"nodeType":"162","messageId":"163","endLine":1419,"endColumn":12},{"ruleId":"160","severity":1,"message":"167","line":1426,"column":9,"nodeType":"162","messageId":"163","endLine":1426,"endColumn":24},{"ruleId":"160","severity":1,"message":"168","line":1462,"column":14,"nodeType":"162","messageId":"163","endLine":1462,"endColumn":15},{"ruleId":"155","severity":1,"message":"156","line":1466,"column":37,"nodeType":"157","messageId":"158","endLine":1466,"endColumn":39},{"ruleId":"155","severity":1,"message":"156","line":1468,"column":66,"nodeType":"157","messageId":"158","endLine":1468,"endColumn":68},{"ruleId":"155","severity":1,"message":"156","line":1472,"column":42,"nodeType":"157","messageId":"158","endLine":1472,"endColumn":44},{"ruleId":"160","severity":1,"message":"168","line":1481,"column":11,"nodeType":"162","messageId":"163","endLine":1481,"endColumn":12},{"ruleId":"160","severity":1,"message":"169","line":1486,"column":12,"nodeType":"162","messageId":"163","endLine":1486,"endColumn":13},{"ruleId":"155","severity":1,"message":"156","line":1507,"column":28,"nodeType":"157","messageId":"158","endLine":1507,"endColumn":30},{"ruleId":"155","severity":1,"message":"156","line":1507,"column":58,"nodeType":"157","messageId":"158","endLine":1507,"endColumn":60},{"ruleId":"155","severity":1,"message":"156","line":1544,"column":20,"nodeType":"157","messageId":"158","endLine":1544,"endColumn":22},{"ruleId":"155","severity":1,"message":"156","line":1559,"column":30,"nodeType":"157","messageId":"158","endLine":1559,"endColumn":32},{"ruleId":"170","severity":1,"message":"171","line":1585,"column":10,"nodeType":"162","messageId":"172","endLine":1585,"endColumn":16},{"ruleId":"170","severity":1,"message":"173","line":1586,"column":10,"nodeType":"162","messageId":"172","endLine":1586,"endColumn":16},{"ruleId":"155","severity":1,"message":"159","line":1640,"column":51,"nodeType":"157","messageId":"158","endLine":1640,"endColumn":53},{"ruleId":"155","severity":1,"message":"159","line":1644,"column":31,"nodeType":"157","messageId":"158","endLine":1644,"endColumn":33},{"ruleId":"155","severity":1,"message":"156","line":1647,"column":36,"nodeType":"157","messageId":"158","endLine":1647,"endColumn":38},{"ruleId":"155","severity":1,"message":"156","line":1680,"column":46,"nodeType":"157","messageId":"158","endLine":1680,"endColumn":48},{"ruleId":"155","severity":1,"message":"156","line":1687,"column":65,"nodeType":"157","messageId":"158","endLine":1687,"endColumn":67},{"ruleId":"155","severity":1,"message":"159","line":1702,"column":40,"nodeType":"157","messageId":"158","endLine":1702,"endColumn":42},{"ruleId":"155","severity":1,"message":"156","line":1711,"column":40,"nodeType":"157","messageId":"158","endLine":1711,"endColumn":42},{"ruleId":"155","severity":1,"message":"156","line":1794,"column":31,"nodeType":"157","messageId":"158","endLine":1794,"endColumn":33},{"ruleId":"155","severity":1,"message":"156","line":1799,"column":16,"nodeType":"157","messageId":"158","endLine":1799,"endColumn":18},{"ruleId":"155","severity":1,"message":"156","line":1811,"column":8,"nodeType":"157","messageId":"158","endLine":1811,"endColumn":10},{"ruleId":"155","severity":1,"message":"156","line":1812,"column":17,"nodeType":"157","messageId":"158","endLine":1812,"endColumn":19},{"ruleId":"155","severity":1,"message":"156","line":1819,"column":16,"nodeType":"157","messageId":"158","endLine":1819,"endColumn":18},{"ruleId":"155","severity":1,"message":"156","line":1819,"column":32,"nodeType":"157","messageId":"158","endLine":1819,"endColumn":34},{"ruleId":"155","severity":1,"message":"156","line":1819,"column":43,"nodeType":"157","messageId":"158","endLine":1819,"endColumn":45},{"ruleId":"155","severity":1,"message":"156","line":1819,"column":59,"nodeType":"157","messageId":"158","endLine":1819,"endColumn":61},{"ruleId":"155","severity":1,"message":"156","line":1819,"column":70,"nodeType":"157","messageId":"158","endLine":1819,"endColumn":72},{"ruleId":"155","severity":1,"message":"156","line":1819,"column":86,"nodeType":"157","messageId":"158","endLine":1819,"endColumn":88},{"ruleId":"155","severity":1,"message":"156","line":1822,"column":14,"nodeType":"157","messageId":"158","endLine":1822,"endColumn":16},{"ruleId":"155","severity":1,"message":"156","line":1825,"column":14,"nodeType":"157","messageId":"158","endLine":1825,"endColumn":16},{"ruleId":"155","severity":1,"message":"156","line":1828,"column":14,"nodeType":"157","messageId":"158","endLine":1828,"endColumn":16},{"ruleId":"155","severity":1,"message":"156","line":1831,"column":14,"nodeType":"157","messageId":"158","endLine":1831,"endColumn":16},{"ruleId":"155","severity":1,"message":"159","line":1834,"column":42,"nodeType":"157","messageId":"158","endLine":1834,"endColumn":44},{"ruleId":"155","severity":1,"message":"159","line":1837,"column":38,"nodeType":"157","messageId":"158","endLine":1837,"endColumn":40},{"ruleId":"155","severity":1,"message":"159","line":1855,"column":14,"nodeType":"157","messageId":"158","endLine":1855,"endColumn":16},{"ruleId":"155","severity":1,"message":"159","line":1861,"column":39,"nodeType":"157","messageId":"158","endLine":1861,"endColumn":41},{"ruleId":"155","severity":1,"message":"159","line":1878,"column":37,"nodeType":"157","messageId":"158","endLine":1878,"endColumn":39},{"ruleId":"155","severity":1,"message":"159","line":1883,"column":56,"nodeType":"157","messageId":"158","endLine":1883,"endColumn":58},{"ruleId":"155","severity":1,"message":"159","line":1884,"column":54,"nodeType":"157","messageId":"158","endLine":1884,"endColumn":56},{"ruleId":"155","severity":1,"message":"156","line":1892,"column":32,"nodeType":"157","messageId":"158","endLine":1892,"endColumn":34},{"ruleId":"155","severity":1,"message":"159","line":1905,"column":47,"nodeType":"157","messageId":"158","endLine":1905,"endColumn":49},{"ruleId":"160","severity":1,"message":"161","line":1914,"column":11,"nodeType":"162","messageId":"163","endLine":1914,"endColumn":12},{"ruleId":"160","severity":1,"message":"174","line":1929,"column":9,"nodeType":"162","messageId":"163","endLine":1929,"endColumn":13},{"ruleId":"155","severity":1,"message":"159","line":1941,"column":27,"nodeType":"157","messageId":"158","endLine":1941,"endColumn":29},{"ruleId":"155","severity":1,"message":"159","line":1941,"column":114,"nodeType":"157","messageId":"158","endLine":1941,"endColumn":116},{"ruleId":"155","severity":1,"message":"159","line":1944,"column":26,"nodeType":"157","messageId":"158","endLine":1944,"endColumn":28},{"ruleId":"155","severity":1,"message":"156","line":1948,"column":32,"nodeType":"157","messageId":"158","endLine":1948,"endColumn":34},{"ruleId":"155","severity":1,"message":"156","line":1966,"column":51,"nodeType":"157","messageId":"158","endLine":1966,"endColumn":53},{"ruleId":"155","severity":1,"message":"156","line":1966,"column":101,"nodeType":"157","messageId":"158","endLine":1966,"endColumn":103},{"ruleId":"155","severity":1,"message":"159","line":1981,"column":16,"nodeType":"157","messageId":"158","endLine":1981,"endColumn":18},{"ruleId":"155","severity":1,"message":"159","line":1984,"column":42,"nodeType":"157","messageId":"158","endLine":1984,"endColumn":44},{"ruleId":"155","severity":1,"message":"156","line":1998,"column":39,"nodeType":"157","messageId":"158","endLine":1998,"endColumn":41},{"ruleId":"160","severity":1,"message":"175","line":2004,"column":10,"nodeType":"162","messageId":"163","endLine":2004,"endColumn":11},{"ruleId":"155","severity":1,"message":"159","line":2007,"column":10,"nodeType":"157","messageId":"158","endLine":2007,"endColumn":12},{"ruleId":"155","severity":1,"message":"156","line":2007,"column":70,"nodeType":"157","messageId":"158","endLine":2007,"endColumn":72},{"ruleId":"155","severity":1,"message":"156","line":2024,"column":30,"nodeType":"157","messageId":"158","endLine":2024,"endColumn":32},{"ruleId":"155","severity":1,"message":"159","line":2040,"column":26,"nodeType":"157","messageId":"158","endLine":2040,"endColumn":28},{"ruleId":"155","severity":1,"message":"159","line":2043,"column":55,"nodeType":"157","messageId":"158","endLine":2043,"endColumn":57},{"ruleId":"155","severity":1,"message":"159","line":2046,"column":25,"nodeType":"157","messageId":"158","endLine":2046,"endColumn":27},"no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-redeclare","'x' is already defined.","Identifier","redeclared","'y' is already defined.","'safeDestination' is already defined.","'a' is already defined.","'playerMarkerPos' is already defined.","'m' is already defined.","'n' is already defined.","no-unused-vars","'shiftX' is assigned a value but never used.","unusedVar","'shiftY' is assigned a value but never used.","'dest' is already defined.","'b' is already defined."]